```asm
Dump of assembler code for function input:
   0x000000000040125c <+0>:     endbr64
   0x0000000000401260 <+4>:     push   %rbp
   0x0000000000401261 <+5>:     mov    %rsp,%rbp
=> 0x0000000000401264 <+8>:     sub    $0x30,%rsp
   ;第一个函数参数
   0x0000000000401268 <+12>:    mov    %rdi,-0x28(%rbp)
   
   ;printf("Enter an expression (length up to %d):\n", MAXLEN)
   {
   ;MAXLEN
   0x000000000040126c <+16>:    mov    $0xf,%esi
   0x0000000000401271 <+21>:    lea    0xdb0(%rip),%rdi        # 0x402028
   ;将eax寄存器清零，作为printf的返回值寄存器
   0x0000000000401278 <+28>:    mov    $0x0,%eax
   0x000000000040127d <+33>:    call   0x4010f0 <printf@plt>
   }
   
   ;gets函数
   {
   0x0000000000401282 <+38>:    lea    -0x20(%rbp),%rax
   0x0000000000401286 <+42>:    mov    %rax,%rdi
   0x0000000000401289 <+45>:    call   0x401100 <gets@plt>
   }
   ;测试eax寄存器的值，如果eax为0，则表示gets读取到的输入为空字符串
   0x000000000040128e <+50>:    test   %eax,%eax
   ;如果eax为0（即没有输入），跳转到0x40129d
   0x0000000000401290 <+52>:    je     0x40129d <input+65>
   0x0000000000401292 <+54>:    lea    -0x20(%rbp),%rax
   ;从rax指向的内存地址中读取一个字节，零扩展到eax
   0x0000000000401296 <+58>:    movzbl (%rax),%eax
   ;测试eax的低位（即读取的字节）是否为0（空字符）
   0x0000000000401299 <+61>:    test   %al,%al
   ;如果不是0（即有内容），跳转到0x4012b3
   0x000000000040129b <+63>:    jne    0x4012b3 <input+87>
   
   ;输入为空
   {
   0x000000000040129d <+65>:    lea    0xdac(%rip),%rdi        # 0x402050
   0x00000000004012a4 <+72>:    call   0x4010c0 <puts@plt>
   0x00000000004012a9 <+77>:    mov    $0x0,%edi
   0x00000000004012ae <+82>:    call   0x401120 <exit@plt>
   }
   
   ;输入不为空
   {:
   0x00000000004012b3 <+87>:    lea    -0x20(%rbp),%rax
   0x00000000004012b7 <+91>:    mov    %rax,%rdi
   0x00000000004012ba <+94>:    call   0x4010d0 <strlen@plt>
   ;比较返回值和0xf(15)
   0x00000000004012bf <+99>:    cmp    $0xf,%rax
   0x00000000004012c3 <+103>:   ja     0x4012d3 <input+119>
   0x00000000004012c5 <+105>:   lea    -0x20(%rbp),%rax
   0x00000000004012c9 <+109>:   mov    %rax,%rdi
   0x00000000004012cc <+112>:   call   0x4010d0 <strlen@plt>
   0x00000000004012d1 <+117>:   jmp    0x4012d8 <input+124>
   ;字符串长度至多为15
   0x00000000004012d3 <+119>:   mov    $0xf,%eax
   ;将eax的值（字符串的最大长度或实际长度）存储到栈中的-0x4位置
   0x00000000004012d8 <+124>:   mov    %eax,-0x4(%rbp)
   ;从栈中加载参数（rdi保存的值）到rax
   0x00000000004012db <+127>:   mov    -0x28(%rbp),%rax
   ;加载"echo $(("到rdx，并存储到rax指向的内存位置
   0x00000000004012df <+131>:   mov    0xd22(%rip),%rdx        # 0x402008 <wrapper_front>
   0x00000000004012e6 <+138>:   mov    %rdx,(%rax)
   ;0x402010 <wrapper_front+8>:""，零扩展到edx，低8位存储到rax+0x8位置
   0x00000000004012e9 <+141>:   movzbl 0xd20(%rip),%edx        # 0x402010 <wrapper_front+8>
   0x00000000004012f0 <+148>:   mov    %dl,0x8(%rax)
   ;加载先前存储的字符串长度或最大长度到eax并作位扩展
   0x00000000004012f3 <+151>:   mov    -0x4(%rbp),%eax
   0x00000000004012f6 <+154>:   cltq
   ;rax+8的地址存储在rdx
   0x00000000004012f8 <+156>:   lea    0x8(%rax),%rdx
   ;传递当前函数的参数给rax
   0x00000000004012fc <+160>:   mov    -0x28(%rbp),%rax
   ;rax 是基地址，加上 rdx（偏移量）
   0x0000000000401300 <+164>:   add    %rdx,%rax
   0x0000000000401303 <+167>:   movzwl 0xd07(%rip),%edx        # 0x402011 <wrapper_back>
   0x000000000040130a <+174>:   mov    %dx,(%rax)
   0x000000000040130d <+177>:   movzbl 0xcff(%rip),%edx        # 0x402013 <wrapper_back+2>
   0x0000000000401314 <+184>:   mov    %dl,0x2(%rax)
   0x0000000000401317 <+187>:   mov    -0x4(%rbp),%eax
   0x000000000040131a <+190>:   movslq %eax,%rdx
   0x000000000040131d <+193>:   mov    -0x28(%rbp),%rax
   0x0000000000401321 <+197>:   lea    0x8(%rax),%rcx
   0x0000000000401325 <+201>:   lea    -0x20(%rbp),%rax
   ;将源字符串复制到目标地址中（指定长度），rdi 是目标地址，rsi 是源地址
   0x0000000000401329 <+205>:   mov    %rax,%rsi
   0x000000000040132c <+208>:   mov    %rcx,%rdi
   0x000000000040132f <+211>:   call   0x4010b0 <strncpy@plt>
   0x0000000000401334 <+216>:   nop
   0x0000000000401335 <+217>:   leave
   0x0000000000401336 <+218>:   ret
```



```asm
Dump of assembler code for function eval:
   0x0000000000401216 <+0>:     endbr64
   0x000000000040121a <+4>:     push   %rbp
   0x000000000040121b <+5>:     mov    %rsp,%rbp
   0x000000000040121e <+8>:     sub    $0x10,%rsp
   0x0000000000401222 <+12>:    mov    %rdi,-0x8(%rbp)
   0x0000000000401226 <+16>:    mov    -0x8(%rbp),%rax
   0x000000000040122a <+20>:    mov    %rax,%rsi
   0x000000000040122d <+23>:    lea    0xde0(%rip),%rdi        # 0x402014
   0x0000000000401234 <+30>:    mov    $0x0,%eax
   0x0000000000401239 <+35>:    call   0x4010f0 <printf@plt>
   0x000000000040123e <+40>:    mov    -0x8(%rbp),%rax
   0x0000000000401242 <+44>:    mov    %rax,%rdi
   0x0000000000401245 <+47>:    call   0x4010e0 <system@plt>
   0x000000000040124a <+52>:    mov    0x2e1f(%rip),%rax        # 0x404070 <stdout@@GLIBC_2.2.5>
   0x0000000000401251 <+59>:    mov    %rax,%rdi
   0x0000000000401254 <+62>:    call   0x401110 <fflush@plt>
   0x0000000000401259 <+67>:    nop
   0x000000000040125a <+68>:    leave
   0x000000000040125b <+69>:    ret
End of assembler dump.
```



### `rbp`（Base Pointer）

- 作用：`rbp`寄存器通常被称为栈基指针。它指向当前栈帧的基址，帮助定位函数参数、局部变量等。栈帧是每个函数调用在栈上为其局部数据分配的区域。
- 用法：
  - 当进入一个函数时，`rbp`的值会被保留，并且栈基指针通常会被更新为当前栈的指针值（即`rsp`）。
  - `rbp`指向当前栈帧的底部，而栈中的局部变量和函数参数则通过偏移量相对于`rbp`来访问。

### `rsp`（Stack Pointer）

- 作用：`rsp`寄存器是栈指针寄存器，它指向栈顶的位置。栈是一个后进先出（LIFO）的数据结构，`rsp`指向栈中最后一个被压入的值。
- 用法：
  - 当函数调用时，`rsp`指向栈的顶部，函数调用会把返回地址、保存的寄存器等压入栈中。
  - `rsp`随着函数的调用和返回动态变化。当函数调用结束时，`rsp`会回到调用前的位置。