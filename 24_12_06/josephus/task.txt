## 题目

填补初始代码，函数 `josephus` 利用单循环列表实现以下约瑟夫环求解：有 n 个人站成一列。并从头到尾给他们编号，第一个人编号为 1 。然后从头开始报数，第一轮依次报 1，2，1，2… 然后报到2的人出局。接着第二轮再从上一轮最后一个报数的人开始依次报 1，2，3，1，2，3... 报到 2，3 的人出局。以此类推直到剩下以后一个人。
函数声明 `int josephus(linkNode *head)`
函数接收构造好的单循环链表头指针，按规则依次删除所有链表节点，返回最后那个人的编号。

##### 编程要求

根据提示，在右侧编辑器补充代码。

##### 测试说明

输入描述:
人数 n

输出描述:
最后剩下那个人的编号。

##### 平台测试：

测试输入：
5

预期输出：
5

##### 代码框架

```c
#include <iostream>
using namespace std;

struct linkNode
{ 
 int id;   
 linkNode *next; 
};

int josephus(linkNode *head)
{
  //complete the implementation

}

int main()
{
  int n;
  cin >> n; // obtain the number of people

  linkNode *head;
  // creat the chain

  cout << josephus(head);
  return 0;
}
```

##### 测试集

| INPUT | OUTPUT |
| ----- | ------ |
| 1     | 1      |
| 2     | 1      |
| 3     | 3      |
| 4     | 3      |
| 5     | 5      |
| 6     | 5      |
| 7     | 5      |
| 8     | 5      |
| 9     | 5      |
| 10    | 5      |
| 30    | 17     |
| 40    | 17     |
| 50    | 41     |

##### 参考逻辑(伪代码) ver0

```c
创建环形链表；
int round = 1;
while (current->next!=current) {
	int count = 1;
	遍历一次链表：
		每到一个节点：
			if (count<round+1 && count!=1) {
				current->id = -1; // 标记为待删除的节点
				count++;
			} else if (count==round+1) {
				count = 1;
			}
	遍历一次链表： // 删除之前标记过的节点
		每到一个节点：
			if (current->next->id == -1) {
				current->next = current->next->next;
			}
}
```

##### 参考代码

```cpp
#include <iostream>
using namespace std;

struct linkNode
{
    int id;
    linkNode *next;
};

int josephus(linkNode *head)
{
    int round = 1; // 第几轮
    linkNode *last_live = head; // 最后一个存活节点
    linkNode *last_live_copy = last_live; // 最后一个存活节点的copy

    while (head->next != head) // 当链表长度大于1时
    {
        int count = 1;           // 报数器

        // 从最后一个报数且存活的节点开始
        linkNode *curr = last_live;

        // cout << "Round " << round << ":\n";
        // cout << "Last live node: " << last_live->id << endl;
        // cout << "Last live node's copy: " << last_live_copy->id << endl;

        // 遍历一次链表，标记待删除节点
        do
        {
            if (count < round + 1 && count != 1)
            {
                // cout << curr->id << " switched to -1\n";
                curr->id = -1; // 标记为待删除
                count++;
            }
            else if (count == round + 1)
            {
                // cout << curr->id << " switched to -1\n";
                curr->id = -1; // 标记为待删除
                count = 1; // 重置报数器
            }
            else
            {
                count++;
                last_live = curr; // 更新最后一个存活节点
            }
            curr = curr->next; // 移动到下一个节点
        } while (curr != last_live_copy);

        // 遍历一次链表，删除标记过的节点
        curr = last_live_copy;
        do
        {
            if (curr->next->id == -1)
            {
                linkNode *toDelete = curr->next;

                // cout << "Node " << toDelete->id << " deleted\n";
                // cout << "prev: " << curr->id << endl;

                curr->next = curr->next->next; // 删除节点

                if (toDelete == head) // 如果头节点被删除
                {
                    head = curr->next; // 更新头节点
                }
                delete toDelete;
            }
            else
            {
                curr = curr->next;
            }
        } while (curr->next != last_live_copy);

        last_live_copy = last_live; // 更新最后一个存活节点的copy
        round++; // 进入下一轮
    }

    return head->id; // 返回最后一个节点的编号
}

int main()
{
    int n;
    cin >> n; 

    linkNode *head = new linkNode();
    head->id = 1;
    linkNode *tail = head;

    for (int i = 2; i <= n; i++)
    {
        linkNode *node = new linkNode();
        node->id = i;
        tail->next = node;
        tail = node;
    }
    tail->next = head; 

    cout << josephus(head);
    return 0;
}
```

