## T1  扫雷地图

经典游戏扫雷中，给出一张n * n的地图,每个格子上给出了周围8个格子(边角为5或3个)存在的地雷数量，玩家需要根据这个信息猜测出某个格子上是否有地雷。
现在给出一张3维空间中的地图，上面标示了某处是否有地雷，没有地雷的地方用数字标识了周围的地雷数量(未必正确，但在0~7之间)，还有一个'?'位置,表示不清楚该地点是否有地雷。请注意，周围地雷数量仅考虑直接相邻的6个点(直观来说，即上下前后左右方向共6个点)。

现在请你判断该地图是否有可能成为一张合法的扫雷地图，成为一张合法扫雷地图的条件是:
'?'位置有地雷或者没有地雷的情况下，地图上数字标识全部正确(详情见示例)
如果可以成为合法地图，那么输出'valid'以及合法地图中'?' 处应该填入的字符，如果不能成为合法地图，那么输出' invalid'以及'?' 处有地雷情况下不正确的数字标识的坐标，横纵坐标都从1开始。

#### 输入格式

第一行为一个n(1 < n < 600),表示地图大小为n X n X n。接下来为地图，'*'表示有地雷。若地图有错误,保证地图上错误的点不超过35个(如果你好奇这个数字怎么来的，不妨思考一下 7 * 5 的结果)。

其中地图格点按以下顺序给出:
1.按照从坐标(1,1,1)到(n, n, n)的顺序排列;
2.坐标顺序符合字典序:即先固定高维坐标，依次递增低维坐标。
即按照坐标
(1,1,1)...(1,1,n),(1,2,1)...(1, 2,n),....,(1,n,1)...(1,n,n),...,(n,n,1).
的顺序依次给出地图.上的点。

注:地图中地雷的数量约占整幅地图的80%，实现时注意效率,避免不必要的计算，本题时限给到了标程的三倍，但太劣的实现依旧无法通过。

#### 输出格式

如果可以成为合法地图，那么输出'valid' 以及'?' 处应该填入的字符，要求输出地雷数量最少的情况下'?'处的字符(图中'*'表示地雷，其余位置表示周围的地雷数目(0~ 6))

否则输出' invalid'以及'?'处有地雷情况下不正确的数字标识的坐标，横纵坐标都从1开始，坐标的输出顺序要求符合字典序。

#### 测试样例

Input：

```
2
*2***2?*
```

Output:

```
valid
3
```

Input:

```
2
3****24?
```

Output:

```
invalid
2 1 2
2 2 1
```



## T2  打地鼠

游戏包含一个 n*m 的网格地图(如下图所示)，地图上的每个格点都有一只地鼠(请自行想象)。
记第x行第y列的格点坐标为(x,y),其中1≤x≤n,1≤y≤m。注意,此处从1开始。
记(x, y)格点上的地鼠的价值为V(x, y) (可以为负值)。
小z用一把旋转了45度的正方形锤子打地鼠，锤子的对角线长度为2d十1。
假设小z落锤的中心点为(x_0,y_0)，则所在坐标(x,y)满足|x-x_0|+|y-y_0| <= d条件的地鼠都被打到了。
注意，只考虑地图上的格点，不考虑超出地图的格点。
示例:
设n= 10,m= 15,d= 2。蓝色(左上角位置)、青色(中间位置)、黄色(右下角位置)分别表示三种落锤情况下能够打到的格点。

<img src=.\figs\2.png width=400>

一次落锤可以获得的价值为当次落锤被打到的地鼠价值的总和。
小z想要最大化一次落锤的价值。
请你写一个程序帮助小z计算最大价值以及所有能取到该最大价值的落锤中心点坐标。

#### 输入格式

第一行包含三个整数: n, m,d.
接下来，有一个n X m的整数数阵，数阵的(i, j)项表示价值V(i,j)。

#### 输出格式

第一行输出两个整数:
●maxValue 表示最大价值
●ansN 表示可以取到最大价值的落锤中心点坐标的数量
接下来有ansN行，每一行包含两个整数 x_i 和 y_i，表示一个中心点坐标。
你可以按照任意顺序输出这些中心点坐标。

#### 测试样例

Input:

```
4 6 1
-3 4 5 4 3 2
1 6 1 7 5 2
9 9 0 0 8 -3
8 8 4 4 -3 2
```

Output:

```
32 1
3 2
```



## T3 Buddy算法

下面给出Buddy算法分配内存过程的较为形式化的描述，供参考:
●初始时，计算机内存为一块，大小给定，此时的”空间链仅包含一个"空间节点”。
●分配内存时，假设需要的内存块大小为2^k:
1.寻找现有的大小恰好为2^k的"空间节点"中是否有还未被分配的。
2.若有，分配最靠前的那个。
3.若没有，则寻找大小 > 2^k的、最靠前的、未被分配的”空间节点", 将其分裂成大小分别为原来一半、位置相邻的两个新“空间节点"，按次序连接之后替换原"空间链"中被分裂的节点; 重复过程1。
在此题中，你需要支持两种操作:
●A id m 表示一个识别码为 id 的程序请求大小为 m 的内存空间。
●Q 表示查询系统中当前空间的分配情况。

#### 输入格式

●第一行输入两个正整数n(n < 31)和q(q≤10000),以空格隔开,分别表示计算机的内存大小为2^n以及操作的总数。
●接下来有q行，每行一个操作，格式如上所述。

#### 限制与约定

●对于30%的数据，保证计算机每次分配的内存空间都相同。
●对于100%的数据，保证n < 31,q < 10000，保证每次操作合法，即: 内存空间足够，应用程序的id互不相同，id不为0。

#### 输出格式

对于每一个 Q 询问，输出两行:
●第一行为一个整数 m，表示当前"空间链结点’的总数。
●第二行依次输出 m 个整数，按照起始地址从小到大输出每一个"空间结点"上的应用程序的 id，若某节点空闲，则输出0。

#### 测试样例

Input

```
4 7
Q
A 1 1
Q
A 2 1
Q
A 3 2
Q
```

Output

```
1
0
5
1 0 0 0 0
5
1 2 0 0 0
5
1 2 3 0 0
```



## T4  数正方形

<img src=./figs/4.jpg width=500>

图1中，只有1个2√2 X 2√2的正方形;
图2中，有32个√2x√2的正方形，18个2√2 x 2√2的正方形，8个3√2 x 3√2的正方形以及2个4√2 x 4√2的正方形，共有60个正方形(不计网格线围成的正方形，只考虑对角线和反对角线围成的正方形)。
作为一名程序员，请你"数”一下图中共有多少个(由对角线、反对角线构成的)正方形。

#### 输入格式

- 第一行包含两个整数:

  - R :表示网格的行数

  - C :表示网格的列数

- 接下来 R 行，每行 C 个字符，表示单元格中的对角线和反对角线
  - / 表示对角线
  - \ 表示反对角线(注意，在C语言中，需要用转义的字符'\\\\'表示反斜杠\;直接使用'\\' 会导致编译错误)
- 保证所有输入数据使用 \n 换行，建议使用 C 控制字符读入

#### 输出格式

输出一个整数，表示正方形的个数(可能为 0 )。
