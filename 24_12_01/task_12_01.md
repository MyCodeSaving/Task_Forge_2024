# T1

##### 描述

Tom 正在学 1000 以内的数字，但是他的数学不是很好。
Jerry 想了个办法，他拿来很多带有数字的积木，随机拼成一长排，让 Tom 拿走连续的最大的**三位数**。
根据主函数和头文件提示，编写子函数 `void findMaxNumber(char *s, int len, int *start)`，从字符串中找到最大连续三位数的起始位置。

##### 输入

输入一个字符串 s （s 中只包含数字字符，其长度在 4~1000 之间）。

##### 输出

根据返回的最大三位数起始位置，输出拿走后剩余的字符串。当有多个最大三位数符合要求时，拿走第一个出现的最大三位数。

##### 输入示例

```
2689643878981
```

##### 输出示例

```
2689643878
```

##### main.c

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "findMaxNumber.h"

char s[MAX_SIZE];

void removeNumber(char *s, int len, int start) {
    for (int i = start; i < len - 2; i++) {
        s[i] = s[i + 3];
    }
    s[len - 2] = '\0';
}

int main() {
    scanf("%s", s);

    int len = strlen(s);
    int start = 0;
    findMaxNumber(s, len, &start);
    removeNumber(s, len, start);

    printf("%s\n", s);

    return 0;
}
```

##### findMaxNumber.h

```c
#define MAX_SIZE 1005 // Maximum string size
void findMaxNumber(char *s, int len, int *start);
```

##### findMaxNumber.c

```c
#include "findMaxNumber.h"
#include <string.h>

void findMaxNumber(char *s, int len, int *start) {
    int maxVal = -1;  // 最大值初始化为 -1，确保任何合法三位数都比它大
    int tempVal;

    for (int i = 0; i <= len - 3; i++) {
        // 提取当前三位数
        tempVal = (s[i] - '0') * 100 + (s[i + 1] - '0') * 10 + (s[i + 2] - '0');
        
        // 更新最大值和起始位置
        if (tempVal > maxVal) {
            maxVal = tempVal;
            *start = i;
        }
    }
}
```

##### 代码解释

1. 遍历三位数

   - 通过 `s[i], s[i+1], s[i+2]` 形成当前的三位数。
   - 将字符转为数字后，计算其数值。

2. 更新最大值

   - 用 `tempVal` 保存当前三位数值。
   - 如果 `tempVal > maxVal`，更新 `maxVal` 和 `*start`。

3. 主函数

   - 主函数调用 `findMaxNumber` 获取最大值的起始位置。
   - 调用 `removeNumber` 移除最大三位数，输出结果。

   

# T2

##### 描述

根据主函数和头文件提示，编写值升序与值降序排列函数，并通过函数指针，根据需求实现升序 / 降序功能。

##### 输入

第1行输入数据个数；
第2行输入对应数据个数的数据，以空格间隔；
第3行输入1或2，选择升序或降序

##### 输出

输出升序或降序的数据排列结果

##### 输入示例

```
5
7 9 11 5 20
1
```

##### 输出示例

```
5 7 9 11 20
```

##### Hint

需要编写值升序、值降序函数以及函数指针相关函数；
cmp在调用排序函数时使用

##### main.c

```c
#include "header.h"
#include <math.h>
#include<stdio.h>

// 注：cmpAsc为值升序函数，cmpDesc为值降序函数

int main() {
    int temps[1000];
    int len;
    int order;
    int (*compare)(const void*, const void*) = NULL;

// 第一行：输入数据个数 
    if (scanf("%d", &len) != 1 || len <= 0 || len > 1000) {
        return 1;
    }

// 第二行：输入数据，空格分割
    for (int i = 0; i < len; i++) {
        int temp;
        if (scanf("%d", &temp) != 1) {
            printf("error\n");
            return 1; //程序终止 
        }
        temps[i] = temp;
    }

// 第三行：选择排序方式 1: 升序, 2: 降序
    scanf("%d", &order);
    compare = (order == 1) ? cmpAsc : cmpDesc;
    sortData(temps, len, compare);

// 输出排序后的数据 
    for (int i = 0; i < len; i++) {
        printf("%d ", temps[i]);
    }
    return 0;
}
```

##### header.h

```c
#include <stdio.h>
#include <stdlib.h>

//函数声明
void sortData(int data[], int len, int (*cmp)(const void*, const void*));
int cmpAsc(const void* a, const void* b);
int cmpDesc(const void* a, const void* b);

extern int temps[1000];// 全局变量声明
```

##### col.c

```c
#include "header.h"

// 升序比较函数
int cmpAsc(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

// 降序比较函数
int cmpDesc(const void* a, const void* b) {
    return (*(int*)b - *(int*)a);
}

// 排序函数
void sortData(int data[], int len, int (*cmp)(const void*, const void*)) {
    qsort(data, len, sizeof(int), cmp);
}
```

##### 代码解析

1. 升序比较函数
   - 比较两个整数的大小，按 `*(int*)a - *(int*)b` 返回升序结果。
2. 降序比较函数
   - 比较两个整数的大小，按 `*(int*)b - *(int*)a` 返回降序结果。
3. 排序函数
   - 使用标准库函数 `qsort` 排序，传入比较函数指针 `cmp` 实现灵活的排序逻辑。
4. 主函数调用
   - 根据输入选择排序方式，传递对应的比较函数指针，调用 `sortData` 完成排序。

##### 注意事项

- 输入数据长度范围（1 到 1000）已在主函数中验证。
- 程序对异常输入（如非整数、超范围等）做了简单处理。
- 全局变量 `temps` 在 `header.h` 中声明，确保数组访问一致性。



# T3

##### 描述

在课堂上，我们认识了一种特殊的字符串：回文串。回文串是一个正着读和反着读都一样的字符串。课后，小P发现课上有的回文串还可以分为两个子回文串，他想让你编程帮他统计一下。

给定一个字符串，该字符串会按如下方式进行回文分裂。回文分裂的规则如下：

- 如果该字符串是一个**回文串**，则该字符串可以均分成前后两个部分，这两个字符串将会按同样的规则继续进行分裂。
- 如果该字符串**不是**一个回文串，**或者**该字符串**长度**为 1，则该字符串将停止分裂。

输入一个长度不超过 104 的字符串，希望你计算出，该字符串按回文分裂的方式分裂后，最后会分裂出多少个字符串。

##### 输入

输入一个长度不超过 104 的字符串，字符串中只包含小写字母。

数据保证字符串长度是 2 的幂。

##### 输出

一个整数，表示该字符串回文分裂后，会分裂出新的字符串的个数。

##### 输入示例

```
abbaabba
```

##### 输出示例

```
4
```

##### Hint

样例说明：

`abbaabba` 可以分裂出**两个** `abba` 字符串

每个 `abba` 可以分裂出 `ab` 和 `ba` 两个字符串

`ab` 和 `ba` 两个字符串无法继续分裂下去

所以最后存在四个字符串，`ab` `ba` `ab` `ba`

##### main.c

```c
#include <stdio.h>
#include <string.h>

// 判断字符串是否是回文串
int isPalindrome(const char* s, int start, int end) {
    while (start < end) {
        if (s[start] != s[end]) {
            return 0; // 不是回文串
        }
        start++;
        end--;
    }
    return 1; // 是回文串
}

// 回文分裂函数
int palindromeSplit(const char* s, int start, int end) {
    if (start >= end) {
        return 1; // 单个字符或空串，直接返回计数 1
    }

    if (isPalindrome(s, start, end)) {
        int mid = (start + end) / 2;
        return palindromeSplit(s, start, mid) + palindromeSplit(s, mid + 1, end);
    } else {
        return 1; // 不是回文串，返回计数 1
    }
}

int main() {
    char s[10005];
    scanf("%s", s);

    int len = strlen(s);
    int result = palindromeSplit(s, 0, len - 1);
    printf("%d\n", result);

    return 0;
}
```

##### 代码解析

1. 判断是否是回文串
   - 双指针 `start` 和 `end` 比较字符串头尾字符，若不相等则立即返回 0。
   - 否则继续缩小范围，直至区间无字符或仅剩 1 个字符。
2. 递归分裂逻辑
   - 如果当前字符串是回文串，递归地对前后部分进行处理。
   - 如果当前字符串不是回文串，或者已无法再分裂，返回计数 1。
3. 主函数
   - 读取输入并调用 `palindromeSplit`。
   - 输出最终分裂得到的字符串数量。



# T4

##### 描述

在学习了字符串与函数指针后，John对 `string.h` 中常用的字符串操作很感兴趣，因此他想自己实现这些操作，但他对C语言指针的操作不是很熟悉，想要请你帮他实现这些函数。

主函数与头文件已给出，请在 `my_string.c` 中实现以下字符串操作函数：

```
/**
 * my_strcpy - Copy string
 * @dest: Destination string
 * @src: Source string
 * Returns: Pointer to the destination string
 */
char *my_strcpy(char *dest, const char *src);

/**
 * my_strncpy - Copy part of a string
 * @dest: Destination string
 * @src: Source string
 * @n: Maximum number of characters to copy
 * Returns: Pointer to the destination string
 */
char *my_strncpy(char *dest, const char *src, size_t n);


/**
 * my_strlen - Calculate the length of a string
 * @str: The string to measure
 * Returns: The length of the string
 */
size_t my_strlen(const char *str);

/**
 * my_strcmp - Compare two strings in ASCII order.
 *    If two strings are equal, return 0; 
 *    If str1 is greater than str2, return 1;
 *    If str1 is less than str2, return -1;
 * @str1: One string
 * @str2: Another string
 */
int my_strcmp(const char *str1, const char *str2);

/**
 * strncmp - Compare the first n pos of two strings in ASCII order.
 *    If two strings are equal, return 0; 
 *    If str1 is greater than str2, return 1;
 *    If str1 is less than str2, return -1;
 * @str1: One string
 * @str2: Another string
 * @n: The maximum number of bytes to compare
 */
int my_strncmp(const char *str1, const char *str2, size_t n);

/**
 * my_strcat - Concatenate two strings
 * @dest: Destination string
 * @src: Source string
 * Returns: Pointer to the destination string
 */
char *my_strcat(char *dest, const char *src);

/**
 * strchr - Find the first occurrence of a character in a string
 * @str: The string to be searched
 * @c: The character to search for
 * Returns: Pointer to the first occurrence character, return a NULL pointer when result cannot be found.
 * Note that the %NUL-terminator is considered part of the string, and can be searched for.
 */
char *my_strchr(const char *str, int c);

/**
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 * Returns: Pointer to the first character of the substring, return a NULL pointer when result cannot be found.
 * Note that the %NUL-terminator is considered part of the string, and can be searched for.
 */
char *my_strstr(const char *s1, const char *s2);

/**
 * my_atoi - Convert a string to an integer
 * @str: The string to convert
 * Returns: The integer value of the string
 */
int my_atoi(const char *str);

/**
 * my_atof - Convert a string to a double
 * @str: The string to convert
 * Returns: The double value of the string
 */
double my_atof(const char *str);
```

##### 输入

测试样例编号。

##### 输出

参考输出示例。

##### 输入示例

```
1
```

##### 输出示例

```
strcpy: Hello, World!
strncpy: Hello
strlen: 13
strcmp: 0
strcmp: 1
strcat: Hello, World! C Programming
strchr: o, World!
strstr: World!
atoi: 123
atoi: -654
atof: 123.456000
atof: -321.654000
```

##### Hint

1. 使用 `size_t` 类型请引头文件 `stddef.h`
2. 函数功能的详细描述参考：[cppreference.com](https://en.cppreference.com/w/)

##### main.c

```c
#include <stdio.h>
#include "my_string.h"


int main() {
	int test_num;
	scanf("%d", &test_num);
	if (test_num == 1) {
	    char src[] = "Hello, World!";
	    char dest[50], destcpy[50];
	    
	    // 使用重定向后的函数
	    strcpy(dest, src);
	    printf("strcpy: %s\n", dest);
	    
	    strncpy(destcpy, src, 5);
		destcpy[5] = '\0'; // 确保字符串以空字符结尾
	    printf("strncpy: %s\n", destcpy);
	    
	    printf("strlen: %zu\n", strlen(src));
	    
	    printf("strcmp: %d\n", strcmp(src, "Hello, World!"));
	    printf("strcmp: %d\n", strcmp(src, "Hallo, World!"));
	    
	    strcat(dest, " C Programming");
	    printf("strcat: %s\n", dest);
	    
	    printf("strchr: %s\n", strchr(src, 'o'));
	    
	    printf("strstr: %s\n", strstr(src, "World"));
	    
	    printf("atoi: %d\n", atoi("123"));
	    printf("atoi: %d\n", atoi("-654"));
	    
	    printf("atof: %f\n", atof("123.456"));
	    printf("atof: %f\n", atof("-321.654"));
	}
	else if (test_num == 2) {
		char src[] = "Hello, Universe!";
		char dest[50], destcpy[50];
		
		// 使用重定向后的函数
		strcpy(dest, src);
		printf("strcpy: %s\n", dest);
		
		strncpy(destcpy, src, 12);
		destcpy[12] = '\0'; // 确保字符串以空字符结尾
		printf("strncpy: %s\n", destcpy);
		
		printf("strlen: %zu\n", strlen(src));
		
		printf("strcmp: %d\n", strcmp(src, "Hello, Universe!"));
		printf("strcmp: %d\n", strcmp(src, "Hello, World!"));
		
		strcat(dest, " in C");
		printf("strcat: %s\n", dest);
		
		printf("strchr: %s\n", strchr(src, '!'));
		
		printf("strstr: %s\n", strstr(src, "Universe"));
		
		printf("atoi: %d\n", atoi("1234"));
		printf("atoi: %d\n", atoi("-5678"));
		
		printf("atof: %f\n", atof("123.45"));
		printf("atof: %f\n", atof("-67.89"));
	}
	else if (test_num == 3) {
		char src[] = "C Programming";
		char dest[50], destcpy[50];
		
		// 使用重定向后的函数
		strcpy(dest, src);
		printf("strcpy: %s\n", dest);
		
		strncpy(destcpy, src, 8);
		destcpy[8] = '\0'; // 确保字符串以空字符结尾
		printf("strncpy: %s\n", destcpy);
		
		printf("strlen: %zu\n", strlen(src));
		
		printf("strcmp: %d\n", strcmp(src, "C Programming"));
		printf("strcmp: %d\n", strcmp(src, "C++ Programming"));
		
		strcat(dest, " is fun");
		printf("strcat: %s\n", dest);
		
		printf("strchr: %s\n", strchr(src, ' '));
		
		printf("strstr: %s\n", strstr(src, "Programming"));
		
		printf("atoi: %d\n", atoi("90"));
		printf("atoi: %d\n", atoi("-20"));
		
		printf("atof: %f\n", atof("45.67"));
		printf("atof: %f\n", atof("-23.45"));
	}
    return 0;
}
```

##### my_string.h

```c
// 重定向函数调用
#define strcpy my_strcpy
#define strncpy my_strncpy
#define strlen my_strlen
#define strcmp my_strcmp
#define strncmp my_strncmp
#define strcat my_strcat
#define strchr my_strchr
#define strstr my_strstr
#define atoi my_atoi
#define atof my_atof
#include <stddef.h>

/**
 * my_strcpy - Copy string
 * @dest: Destination string
 * @src: Source string
 * Returns: Pointer to the destination string
 */
char *my_strcpy(char *dest, const char *src);

/**
 * my_strncpy - Copy part of a string
 * @dest: Destination string
 * @src: Source string
 * @n: Maximum number of characters to copy
 * Returns: Pointer to the destination string
 */
char *my_strncpy(char *dest, const char *src, size_t n);


/**
 * my_strlen - Calculate the length of a string
 * @str: The string to measure
 * Returns: The length of the string
 */
size_t my_strlen(const char *str);

/**
 * my_strcmp - Compare two strings in ASCII order.
 *    If two strings are equal, return 0; 
 *    If str1 is greater than str2, return 1;
 *    If str1 is less than str2, return -1;
 * @str1: One string
 * @str2: Another string
 */
int my_strcmp(const char *str1, const char *str2);

/**
 * strncmp - Compare the first n pos of two strings in ASCII order.
 *    If two strings are equal, return 0; 
 *    If str1 is greater than str2, return 1;
 *    If str1 is less than str2, return -1;
 * @str1: One string
 * @str2: Another string
 * @n: The maximum number of bytes to compare
 */
int my_strncmp(const char *str1, const char *str2, size_t n);

/**
 * my_strcat - Concatenate two strings
 * @dest: Destination string
 * @src: Source string
 * Returns: Pointer to the destination string
 */
char *my_strcat(char *dest, const char *src);

/**
 * strchr - Find the first occurrence of a character in a string
 * @str: The string to be searched
 * @c: The character to search for
 * Returns: Pointer to the first occurrence character, return a NULL pointer when result cannot be found.
 * Note that the %NUL-terminator is considered part of the string, and can be searched for.
 */
char *my_strchr(const char *str, int c);

/**
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 * Returns: Pointer to the first character of the substring, return a NULL pointer when result cannot be found.
 * Note that the %NUL-terminator is considered part of the string, and can be searched for.
 */
char *my_strstr(const char *s1, const char *s2);

/**
 * my_atoi - Convert a string to an integer
 * @str: The string to convert
 * Returns: The integer value of the string
 */
int my_atoi(const char *str);

/**
 * my_atof - Convert a string to a double
 * @str: The string to convert
 * Returns: The double value of the string
 */
double my_atof(const char *str);
```

##### my_string.c

```c
#include "my_string.h"
#include <ctype.h>

// 实现 my_strcpy
char *my_strcpy(char *dest, const char *src) {
    char *ptr = dest;
    while ((*ptr++ = *src++) != '\0');
    return dest;
}

// 实现 my_strncpy
char *my_strncpy(char *dest, const char *src, size_t n) {
    char *ptr = dest;
    while (n && (*ptr++ = *src++) != '\0') {
        n--;
    }
    if (n) { // 如果未完全拷贝，填充剩余部分为 '\0'
        while (n--) {
            *ptr++ = '\0';
        }
    }
    return dest;
}

// 实现 my_strlen
size_t my_strlen(const char *str) {
    const char *ptr = str;
    while (*ptr) {
        ptr++;
    }
    return ptr - str;
}

// 实现 my_strcmp
int my_strcmp(const char *str1, const char *str2) {
    while (*str1 && *str2 && (*str1 == *str2)) {
        str1++;
        str2++;
    }
    if (*str1 > *str2) return 1;
    if (*str1 < *str2) return -1;
    return 0;
}

// 实现 my_strncmp
int my_strncmp(const char *str1, const char *str2, size_t n) {
    while (n && *str1 && *str2 && (*str1 == *str2)) {
        str1++;
        str2++;
        n--;
    }
    if (n == 0) return 0;
    if (*str1 > *str2) return 1;
    if (*str1 < *str2) return -1;
    return 0;
}

// 实现 my_strcat
char *my_strcat(char *dest, const char *src) {
    char *ptr = dest;
    while (*ptr) {
        ptr++;
    }
    while ((*ptr++ = *src++) != '\0');
    return dest;
}

// 实现 my_strchr
char *my_strchr(const char *str, int c) {
    while (*str) {
        if (*str == (char)c) {
            return (char *)str;
        }
        str++;
    }
    return (*str == (char)c) ? (char *)str : NULL;
}

// 实现 my_strstr
char *my_strstr(const char *s1, const char *s2) {
    if (!*s2) return (char *)s1;
    const char *p1, *p2;
    while (*s1) {
        p1 = s1;
        p2 = s2;
        while (*p1 && *p2 && (*p1 == *p2)) {
            p1++;
            p2++;
        }
        if (!*p2) return (char *)s1;
        s1++;
    }
    return NULL;
}

// 实现 my_atoi
int my_atoi(const char *str) {
    while (isspace(*str)) str++; // 跳过空白字符
    int sign = 1;
    if (*str == '-') {
        sign = -1;
        str++;
    } else if (*str == '+') {
        str++;
    }
    int result = 0;
    while (isdigit(*str)) {
        result = result * 10 + (*str - '0');
        str++;
    }
    return sign * result;
}

// 实现 my_atof
double my_atof(const char *str) {
    while (isspace(*str)) str++; // 跳过空白字符
    int sign = 1;
    if (*str == '-') {
        sign = -1;
        str++;
    } else if (*str == '+') {
        str++;
    }
    double result = 0.0;
    while (isdigit(*str)) {
        result = result * 10.0 + (*str - '0');
        str++;
    }
    if (*str == '.') {
        str++;
        double fraction = 1.0;
        while (isdigit(*str)) {
            fraction /= 10.0;
            result += (*str - '0') * fraction;
            str++;
        }
    }
    return sign * result;
}
```

