***两道题目似乎均有误***



### 1. 汉诺塔问题的递归解决

```c
void move(int n, char from, cahr to, char aux) {
    if (n==1) {
        printf("Move disk 1 from %c to %c\n", from, to);
        return;
    }
    move(n-1, from, aux, to);
    printf("Move disk %d from %c to %c\n", n, from, to);
    move(n-1, aux, to, from);
}
int main() {
    int numDisks;
    move(numDisks, 'A', 'B', 'C');
    return 0;
}
```

问：当numDisk=4时，
（1）共有几行输出？
（2）第五行输出的from，to的参数值是？
（3）第十行输出的from，to的参数值是？

#### **1.1. 代码解析**

汉诺塔问题通过递归的方式解决，其逻辑如下：

1. 如果只剩一个盘子，直接将它从 `from` 移到 `to`。
2. 如果有多个盘子：
   - 先将上面的 `n-1` 个盘子从 `from` 移到辅助塔 `aux`。
   - 然后将第 `n` 个盘子从 `from` 移到 `to`。
   - 最后将 `n-1` 个盘子从 `aux` 移到 `to`。

#### **1.2. 解答问题**

**(1) 输出行数 **

对于汉诺塔问题，移动步骤总数为 $2^n - 1$，即输出的行数也是 $2^n - 1$。
当 `numDisks = 4` 时：
$$
2^4 - 1 = 15
$$
因此，共有 15 行输出。

**(2) 第五行输出的 `from` 和 `to` 参数值**

递归过程如下：

- `move(4, A, B, C)`：先处理 `move(3, A, C, B)`。
- `move(3, A, C, B)`：先处理 `move(2, A, B, C)`。
- `move(2, A, B, C)`：先处理 `move(1, A, C, B)`。
  - 这时第一个盘子从 `A` 移到 `B`（第1行输出）。
- 接下来打印第2行输出，将第2个盘子从 `A` 移到 `C`。
- 然后处理 `move(1, B, C, A)`。
  - 这时第一个盘子从 `B` 移到 `C`（第3行输出）。

继续返回：

- 打印第4行输出，将第3个盘子从 `A` 移到 `B`。
- 然后处理 `move(2, C, B, A)`。
  - 先处理 `move(1, C, A, B)`。
    - 这时第一个盘子从 `C` 移到 `A`（第5行输出）。

因此，第五行输出的 `from = C`，`to = A`。

**(3) 第十行输出的 `from` 和 `to` 参数值**

按照递归流程：

- 完成了 `move(3, A, C, B)` 和 `move(4, A, B, C)` 中的前半部分。
- 开始处理 `move(3, C, B, A)`。
  - 在其中，先处理 `move(2, C, A, B)`。
    - 第一步是 `move(1, C, B, A)`。
    - 然后是将第2个盘子从 `C` 移到 `B`（第10行输出）。

因此，第十行输出的 `from = C`，`to = B`。



### 2. 排序问题

```c
void QuikSort(int array[], int low, int high) {
int i = low, j = high, temp = array[low];
    if(i >= j) {
        return;
    }
    while(i != j) {
        while(array[j] >= temp && i < j)
            j--;
        while(array[i] <= temp && i < j)
            i++;
        if(i < j)
            swap(array[i], array[j]);
    }
    swap(array[low], array[i]);
    QuickSort(array, low, i-1);
    QuickSort(array, i+1, high);
}
```

问：当给定的无序序列为6，2，1，3，7，4，9，5，8，0时，每一趟快速排序（左右两个子序列同时进行快排）的结果为？
第一趟：（）
第二趟：（）
......

#### **2.1. 代码解析**

快速排序通过以下步骤实现：

1. 确定基准值 `temp`（通常为当前区间的第一个元素）。
2. 左右指针从两端向中间移动，交换不符合条件的元素。
3. 最终基准值归位到正确位置（此时左侧均小于等于基准，右侧均大于等于基准）。
4. 对左右子序列分别递归进行快排。

#### **2.2. 解答问题**

**初始序列：** `6, 2, 1, 3, 7, 4, 9, 5, 8, 0`。

**第一趟排序（基准值：6）：**

- 左指针从 `6` 开始，右指针从 `0` 开始。
- 交换：`6` 与 `0`，得到 `0, 2, 1, 3, 7, 4, 9, 5, 8, 6`。
- 继续指针移动，交换：`7` 与 `5`，得到 `0, 2, 1, 3, 5, 4, 9, 7, 8, 6`。
- 最后基准值归位，得到 `0, 2, 1, 3, 5, 4, 6, 7, 8, 9`。

结果：`[0, 2, 1, 3, 5, 4]`（左子序列）和 `[7, 8, 9]`（右子序列）。

**第二趟排序：**

- 对左子序列 `[0, 2, 1, 3, 5, 4]` 进行快排，基准值为 `0`，左侧无变化。
  - 结果：`0` 和 `[2, 1, 3, 5, 4]`。
- 对 `[7, 8, 9]` 快排，基准值为 `7`，右侧无变化。
  - 结果：`[7]` 和 `[8, 9]`。

继续细分每趟结果：

1. 第三趟：对 `[2, 1, 3, 5, 4]` 排序，基准值为 `2`。
   - 结果：`[1]` 和 `[3, 5, 4]`。
2. 第四趟：对 `[3, 5, 4]` 排序，基准值为 `3`。
   - 结果：`[3]` 和 `[4, 5]`。
3. 第五趟：对 `[4, 5]` 排序，基准值为 `4`。
   - 结果：`[4]` 和 `[5]`。

**最终结果：**

- 第一次：`[0, 2, 1, 3, 5, 4, 6, 7, 8, 9]`
- 第二次：`[0, 1, 2, 3, 5, 4, 6, 7, 8, 9]`
- 第三次：`[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`
- 排序结束。